/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.systemui.statusbar;

import android.annotation.NonNull;
import android.annotation.SuppressLint;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.ComponentName;
import android.content.Context;
import android.os.RemoteException;
import android.os.UserHandle;
import android.service.notification.StatusBarNotification;
import android.util.Log;

import com.android.systemui.dagger.SysUISingleton;
import com.android.systemui.dagger.qualifiers.Main;
import com.android.systemui.plugins.PluginManager;
import com.android.systemui.statusbar.dagger.CentralSurfacesModule;
import com.android.systemui.statusbar.notification.collection.NotifCollection;
import com.android.systemui.statusbar.notification.collection.PipelineDumpable;
import com.android.systemui.statusbar.notification.collection.PipelineDumper;
import com.android.systemui.statusbar.phone.CentralSurfaces;
import com.android.systemui.statusbar.phone.NotificationListenerWithPlugins;
import com.android.systemui.util.time.SystemClock;

import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.inject.Inject;

// üîπ IMPORT DA LITERTLIB
import devtitans.litertlib.LiteRTLib;

/**
 * This class handles listening to notification updates and passing them along to
 * NotificationPresenter to be displayed to the user.
 */
@SysUISingleton
@SuppressLint("OverrideAbstract")
public class NotificationListener extends NotificationListenerWithPlugins implements
        PipelineDumpable {
    private static final String TAG = "NotificationListener";
    private static final boolean DEBUG = CentralSurfaces.DEBUG;
    private static final long MAX_RANKING_DELAY_MILLIS = 500L;

    private final Context mContext;
    private final NotificationManager mNotificationManager;
    private final SystemClock mSystemClock;
    private final Executor mMainExecutor;
    private final List<NotificationHandler> mNotificationHandlers = new ArrayList<>();

    private final Deque<RankingMap> mRankingMapQueue = new ConcurrentLinkedDeque<>();
    private final Runnable mDispatchRankingUpdateRunnable = this::dispatchRankingUpdate;
    private long mSkippingRankingUpdatesSince = -1;

    // üîπ Armazena notifica√ß√µes por pacote (para agrupamento)
    private final java.util.Map<String, java.util.List<StatusBarNotification>> appNotifications = new java.util.HashMap<>();

    // üîπ VARI√ÅVEIS ADICIONADAS PARA IA
    private final ExecutorService aiExecutor = Executors.newSingleThreadExecutor();
    private final LiteRTLib liteRT = new LiteRTLib();
    private final java.util.Map<String, String> summaryCache = new java.util.HashMap<>();

    /**
     * Injected constructor. See {@link CentralSurfacesModule}.
     */
    @Inject
    public NotificationListener(
            Context context,
            NotificationManager notificationManager,
            SystemClock systemClock,
            @Main Executor mainExecutor,
            PluginManager pluginManager) {
        super(pluginManager);
        mContext = context;
        mNotificationManager = notificationManager;
        mSystemClock = systemClock;
        mMainExecutor = mainExecutor;
    }

    /** Registers a listener that's notified when notifications are added/removed/etc. */
    public void addNotificationHandler(NotificationHandler handler) {
        if (mNotificationHandlers.contains(handler)) {
            throw new IllegalArgumentException("Listener is already added");
        }
        mNotificationHandlers.add(handler);
    }

    @Override
    public void onListenerConnected() {
        if (DEBUG) Log.d(TAG, "onListenerConnected");
        onPluginConnected();
        final StatusBarNotification[] notifications = getActiveNotifications();
        if (notifications == null) {
            Log.w(TAG, "onListenerConnected unable to get active notifications.");
            return;
        }
        final RankingMap currentRanking = getCurrentRanking();
        mMainExecutor.execute(() -> {
            final List<Ranking> newRankings = new ArrayList<>();
            for (StatusBarNotification sbn : notifications) {
                newRankings.add(getRankingOrTemporaryStandIn(currentRanking, sbn.getKey()));
            }
            final RankingMap completeMap = new RankingMap(newRankings.toArray(new Ranking[0]));

            for (StatusBarNotification sbn : notifications) {
                for (NotificationHandler listener : mNotificationHandlers) {
                    listener.onNotificationPosted(sbn, completeMap);
                }
            }
            for (NotificationHandler listener : mNotificationHandlers) {
                listener.onNotificationsInitialized();
            }
        });
    }

    @Override
    public void onNotificationPosted(final StatusBarNotification sbn,
            final RankingMap rankingMap) {
        // üîç LOG 1: Notifica√ß√£o recebida
        Log.d(TAG, "========================================");
        Log.d(TAG, "üì¨ NOTIFICA√á√ÉO RECEBIDA!");
        if (sbn != null) {
            Log.d(TAG, "üì¶ Pacote: " + sbn.getPackageName());
            Log.d(TAG, "üÜî ID: " + sbn.getId());
            Log.d(TAG, "üè∑Ô∏è Tag: " + sbn.getTag());
        } else {
            Log.d(TAG, "‚ö†Ô∏è StatusBarNotification √© NULL!");
        }
        
        if (DEBUG) Log.d(TAG, "onNotificationPosted: " + sbn);

        if (sbn == null) return;

        // üîπ 1. Agrupa notifica√ß√µes por pacote
        String pkg = sbn.getPackageName();
        synchronized (appNotifications) {
            appNotifications.computeIfAbsent(pkg, k -> new java.util.ArrayList<>()).add(sbn);
            int count = appNotifications.get(pkg).size();
            Log.d(TAG, "üî¢ Total de notifica√ß√µes de " + pkg + ": " + count);
        }

        // üîπ 2. Gera ou atualiza notifica√ß√£o-resumo COM IA
        Log.d(TAG, "ü§ñ Chamando postSummaryNotificationWithAI para: " + pkg);
        postSummaryNotificationWithAI(pkg);

        // üîπ 3. Continua o fluxo normal (SystemUI handlers)
        if (!onPluginNotificationPosted(sbn, rankingMap)) {
            mMainExecutor.execute(() -> {
                for (NotificationHandler handler : mNotificationHandlers) {
                    handler.onNotificationPosted(sbn, rankingMap);
                }
            });
        }
    }

    @Override
    public void onNotificationRemoved(StatusBarNotification sbn, RankingMap rankingMap,
            int reason) {
        if (DEBUG) Log.d(TAG, "onNotificationRemoved: " + sbn + " reason: " + reason);
        if (sbn != null && !onPluginNotificationRemoved(sbn, rankingMap)) {
            mMainExecutor.execute(() -> {
                for (NotificationHandler handler : mNotificationHandlers) {
                    handler.onNotificationRemoved(sbn, rankingMap, reason);
                }
            });
        }
    }

    @Override
    public void onNotificationRemoved(StatusBarNotification sbn, RankingMap rankingMap) {
        onNotificationRemoved(sbn, rankingMap, NotifCollection.REASON_UNKNOWN);
    }

    @Override
    public void onNotificationRankingUpdate(final RankingMap rankingMap) {
        if (DEBUG) Log.d(TAG, "onRankingUpdate");
        if (rankingMap != null) {
            RankingMap r = onPluginRankingUpdate(rankingMap);
            mRankingMapQueue.addLast(r);
            mMainExecutor.execute(mDispatchRankingUpdateRunnable);
        }
    }

    private Context getPackageContext(String pkg) {
        try {
            return mContext.createApplicationContext(
                    mContext.getPackageManager().getApplicationInfo(pkg, 0),
                    Context.CONTEXT_IGNORE_SECURITY
            );
        } catch (Exception e) {
            return mContext; // fallback SystemUI
        }
    }

    // üîπ M√âTODO NOVO: Processa resumo com IA
    private void postSummaryNotificationWithAI(String pkg) {
        // üîç LOG 2: M√©todo chamado
        Log.d(TAG, "========================================");
        Log.d(TAG, "ü§ñ postSummaryNotificationWithAI CHAMADO!");
        Log.d(TAG, "üì¶ Pacote: " + pkg);
        
        // üîπ FILTRO: Ignora pr√≥prio SystemUI
        if (pkg.equals("com.android.systemui")) {
            Log.d(TAG, "‚õî IGNORANDO: Pacote √© com.android.systemui (filtro aplicado)");
            return;
        }
        
        java.util.List<StatusBarNotification> list;
        synchronized (appNotifications) {
            list = new java.util.ArrayList<>(appNotifications.get(pkg));
        }

        if (list == null || list.isEmpty()) {
            Log.d(TAG, "‚ö†Ô∏è Lista de notifica√ß√µes vazia para " + pkg);
            return;
        }

        Log.d(TAG, "üìä Total de notifica√ß√µes: " + list.size());

        // Se tem menos de 2 notifica√ß√µes, checa se uma √∫nica notifica√ß√£o √© extensa
        if (list.size() < 2) {
            Log.d(TAG, "üìå Apenas uma notifica√ß√£o detectada. Verificando tamanho...");

            // Extrai texto dessa notifica√ß√£o √∫nica
            CharSequence singleTitle = list.get(0).getNotification().extras
                    .getCharSequence(android.app.Notification.EXTRA_TITLE);
            CharSequence singleText = list.get(0).getNotification().extras
                    .getCharSequence(android.app.Notification.EXTRA_TEXT);

            StringBuilder singleBuilder = new StringBuilder();
            if (singleTitle != null) singleBuilder.append(singleTitle).append(": ");
            if (singleText != null) singleBuilder.append(singleText);

            String textoUnico = singleBuilder.toString();

            // üîΩ LIMITE m√≠nimo para resumo com IA (ajust√°vel)
            final int MIN_LENGTH_FOR_AI = 120;

            if (textoUnico.length() >= MIN_LENGTH_FOR_AI) {
                Log.d(TAG, "üß† Texto √∫nico extenso detectado (" + textoUnico.length() +
                        " chars), processando com IA...");
                postProcessingNotification(pkg, 1);
                aiExecutor.execute(() -> {
                    String aiSummary = liteRT.computePiValue(textoUnico);
                    summaryCache.put(pkg, aiSummary);
                    mMainExecutor.execute(() ->
                        postFinalSummaryNotification(pkg, 1, aiSummary)
                    );
                });
                return;
            }

            // üî∏ Caso contr√°rio, resumo simples
            Log.d(TAG, "üìù Notifica√ß√£o pequena. Usando resumo simples.");
            postSimpleSummaryNotification(pkg, list);
            return;
        }

        Log.d(TAG, "‚úÖ Threshold atingido! Processando com IA...");

        // üî∏ Concatena os textos para enviar √† IA
        StringBuilder summaryText = new StringBuilder();
        for (StatusBarNotification n : list) {
            CharSequence text = n.getNotification().extras
                .getCharSequence(android.app.Notification.EXTRA_TEXT);
            CharSequence title = n.getNotification().extras
                .getCharSequence(android.app.Notification.EXTRA_TITLE);
            
            if (title != null) summaryText.append(title).append(": ");
            if (text != null) summaryText.append(text).append("\n");
        }

        String textoOriginal = summaryText.toString();
        Log.d(TAG, "üìÑ Texto concatenado (" + textoOriginal.length() + " chars): " 
            + textoOriginal.substring(0, Math.min(150, textoOriginal.length())) + "...");
        
        // üî∏ Mostra notifica√ß√£o "processando..." tempor√°ria
        postProcessingNotification(pkg, list.size());

        // üî∏ Processa com IA em background para n√£o travar a UI
        aiExecutor.execute(() -> {
            Log.d(TAG, "üßµ Thread IA iniciada para: " + pkg);            
            //String aiSummary = summaryCache.get(pkg);            
            Log.d(TAG, "üí≠ Chamando LiteRTLib.computePiValue...");
            String aiSummary = liteRT.computePiValue(textoOriginal);
            Log.d(TAG, "üìù Resultado recebido: " + aiSummary);

            // Atualiza o cache sempre com o novo resumo
            summaryCache.put(pkg, aiSummary);

            // Posta a notifica√ß√£o final com o resumo
            final String finalSummary = aiSummary;
            mMainExecutor.execute(() -> {
                Log.d(TAG, "üì≤ Postando notifica√ß√£o final...");
                postFinalSummaryNotification(pkg, list.size(), finalSummary);
            });
        });
    }

    // üîπ M√âTODO NOVO: Notifica√ß√£o tempor√°ria enquanto processa
    private void postProcessingNotification(String pkg, int count) {
        Log.d(TAG, "‚è≥ Postando notifica√ß√£o de processamento...");
        
        Context pkgContext = getPackageContext(pkg);
        android.app.Notification notification = new android.app.Notification.Builder(
                pkgContext, "systemui_summary_channel")
                .setContentTitle(pkg)
                .setContentText("ü§ñ Gerando resumo inteligente...")
                .setSmallIcon(android.R.drawable.ic_popup_sync)
                .setGroup(pkg)
                .setGroupSummary(true)
                .setOngoing(true)
                .build();

        try {
            android.app.NotificationManager nm = mContext
                .getSystemService(android.app.NotificationManager.class);
            ensureChannel(nm, pkgContext);
            nm.notify(pkg.hashCode(), notification);
            Log.d(TAG, "‚úÖ Notifica√ß√£o de processamento postada");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erro ao postar notifica√ß√£o de processamento", e);
        }
    }

    // üîπ M√âTODO NOVO: Notifica√ß√£o final com resumo da IA
    private void postFinalSummaryNotification(String pkg, int count, String aiSummary) {
        Log.d(TAG, "üìù Postando notifica√ß√£o final com resumo...");
        
        Context pkgContext = getPackageContext(pkg);
        android.app.Notification notification = new android.app.Notification.Builder(
                pkgContext, "systemui_summary_channel")
                .setContentTitle(pkg)
                .setContentText("üìù " + aiSummary)
                .setStyle(new android.app.Notification.BigTextStyle()
                    .bigText("ü§ñ Resumo Inteligente:\n" + aiSummary))
                .setSmallIcon(android.R.drawable.ic_dialog_info)
                .setGroup(pkg)
                .setGroupSummary(true)
                .setOngoing(false)
                .build();

        try {
            android.app.NotificationManager nm = mContext
                .getSystemService(android.app.NotificationManager.class);
            ensureChannel(nm, pkgContext);
            nm.notify(pkg.hashCode(), notification);
            Log.d(TAG, "‚úÖ Notifica√ß√£o final postada!");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erro ao postar notifica√ß√£o final", e);
        }
    }

    // üîπ M√âTODO NOVO: Resumo simples (sem IA) para poucas notifica√ß√µes
    private void postSimpleSummaryNotification(String pkg,
            java.util.List<StatusBarNotification> list) {
        Log.d(TAG, "üìã Postando resumo simples (sem IA)...");

        Context pkgContext = getPackageContext(pkg);  // <<< AQUI!

        StringBuilder text = new StringBuilder();
        for (StatusBarNotification n : list) {
            CharSequence t = n.getNotification().extras
                    .getCharSequence(android.app.Notification.EXTRA_TEXT);
            if (t != null) text.append("‚Ä¢ ").append(t).append("\n");
        }

        android.app.Notification notification = new android.app.Notification.Builder(
                pkgContext, "systemui_summary_channel")   // <<< ALTERADO!
                .setContentTitle(pkg + " (" + list.size() + " notifica√ß√µes)")
                .setStyle(new android.app.Notification.BigTextStyle()
                        .bigText(text.toString()))
                .setSmallIcon(android.R.drawable.ic_dialog_info)
                .setGroup(pkg)
                .setGroupSummary(true)
                .build();

        try {
            android.app.NotificationManager nm = mContext
                    .getSystemService(android.app.NotificationManager.class);
            ensureChannel(nm, pkgContext);   // <<< AGORA funciona
            nm.notify(pkg.hashCode(), notification);
            Log.d(TAG, "‚úÖ Resumo simples postado");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erro ao postar resumo simples", e);
        }
    }

    // üîπ M√âTODO NOVO: Garante que o canal existe
    private void ensureChannel(android.app.NotificationManager nm, Context pkgContext) {
        if (nm.getNotificationChannel("systemui_summary_channel") == null) {
            Log.d(TAG, "üì∫ Criando canal de notifica√ß√£o...");
            nm.createNotificationChannel(new android.app.NotificationChannel(
                    "systemui_summary_channel",
                    "Resumos Inteligentes",
                    android.app.NotificationManager.IMPORTANCE_DEFAULT
            ));
        }
    }


    private void dispatchRankingUpdate() {
        if (DEBUG) Log.d(TAG, "dispatchRankingUpdate");
        RankingMap r = mRankingMapQueue.pollFirst();
        if (r == null) {
            Log.wtf(TAG, "mRankingMapQueue was empty!");
        }
        if (!mRankingMapQueue.isEmpty()) {
            final long now = mSystemClock.elapsedRealtime();
            if (mSkippingRankingUpdatesSince == -1) {
                mSkippingRankingUpdatesSince = now;
            }
            final long timeSkippingRankingUpdates = now - mSkippingRankingUpdatesSince;
            if (timeSkippingRankingUpdates < MAX_RANKING_DELAY_MILLIS) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping dispatch of onNotificationRankingUpdate() -- "
                            + mRankingMapQueue.size() + " more updates already in the queue.");
                }
                return;
            }
            if (DEBUG) {
                Log.d(TAG, "Proceeding with dispatch of onNotificationRankingUpdate() -- "
                        + mRankingMapQueue.size() + " more updates already in the queue.");
            }
        }
        mSkippingRankingUpdatesSince = -1;
        for (NotificationHandler handler : mNotificationHandlers) {
            handler.onNotificationRankingUpdate(r);
        }
    }

    @Override
    public void onNotificationChannelModified(
            String pkgName, UserHandle user, NotificationChannel channel, int modificationType) {
        if (DEBUG) Log.d(TAG, "onNotificationChannelModified");
        if (!onPluginNotificationChannelModified(pkgName, user, channel, modificationType)) {
            mMainExecutor.execute(() -> {
                for (NotificationHandler handler : mNotificationHandlers) {
                    handler.onNotificationChannelModified(pkgName, user, channel, modificationType);
                }
            });
        }
    }

    public final void unsnoozeNotification(@NonNull String key) {
        if (!isBound()) return;
        try {
            getNotificationInterface().unsnoozeNotificationFromSystemListener(mWrapper, key);
        } catch (android.os.RemoteException ex) {
            Log.v(TAG, "Unable to contact notification manager", ex);
        }
    }

    public void registerAsSystemService() {
        try {
            registerAsSystemService(mContext,
                    new ComponentName(mContext.getPackageName(), getClass().getCanonicalName()),
                    UserHandle.USER_ALL);
        } catch (RemoteException e) {
            Log.e(TAG, "Unable to register notification listener", e);
        }
    }

    @Override
    public void dumpPipeline(@NonNull PipelineDumper d) {
        d.dump("notificationHandlers", mNotificationHandlers);
    }

    public void addNotificationSettingsListener(NotificationSettingsListener listener) {
        // M√©todo vazio para manter compatibilidade com outros componentes do SystemUI
    }

    private static Ranking getRankingOrTemporaryStandIn(RankingMap rankingMap, String key) {
        Ranking ranking = new Ranking();
        if (!rankingMap.getRanking(key, ranking)) {
            ranking.populate(
                    key,
                    0, false, 0, 0, 0, null, null, null,
                    new ArrayList<>(), new ArrayList<>(),
                    false, 0, false, 0, false,
                    new ArrayList<>(), new ArrayList<>(),
                    false, false, false, null, 0, false, 0, false
            );
        }
        return ranking;
    }

    @Deprecated
    public interface NotificationSettingsListener {
        default void onStatusBarIconsBehaviorChanged(boolean hideSilentStatusIcons) { }
    }

    public interface NotificationHandler {
        void onNotificationPosted(StatusBarNotification sbn, RankingMap rankingMap);
        void onNotificationRemoved(StatusBarNotification sbn, RankingMap rankingMap);
        void onNotificationRemoved(StatusBarNotification sbn, RankingMap rankingMap, int reason);
        void onNotificationRankingUpdate(RankingMap rankingMap);

        default void onNotificationChannelModified(
                String pkgName,
                UserHandle user,
                NotificationChannel channel,
                int modificationType) {
        }

        void onNotificationsInitialized();
    }
}
